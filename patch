diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0ab989a..55331f4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -106,7 +106,9 @@ option(
 option(LCI_ENABLE_MULTITHREAD_PROGRESS
        "LCI_progress can be called by multiple threads simultaneously" OFF)
 option(LCI_IBV_ENABLE_TRY_LOCK_QP
-       "Try to lock the queue pair before access it." ON)
+       "Try to lock the IBV queue pair before access it." ON)
+option(LCI_OFI_ENABLE_TRY_LOCK_EP
+        "Try to lock the OFI endpoint before access it." ON)
 option(LCI_CONFIG_USE_ALIGNED_ALLOC "Enable memory alignment" ON)
 set(LCI_USE_DREG_DEFAULT
     ${LCI_USE_SERVER_IBV}
diff --git a/lci/backend/ofi/server_ofi.c b/src/backend/ofi/server_ofi.c
index 78f3f24..df9e6e8 100644
--- a/src/backend/ofi/server_ofi.c
+++ b/src/backend/ofi/server_ofi.c
@@ -130,6 +130,8 @@ void LCISD_endpoint_init(LCIS_server_t server_pp, LCIS_endpoint_t* endpoint_pp,
   endpoint_p->server = (LCISI_server_t*)server_pp;
   endpoint_p->server->endpoints[endpoint_p->server->endpoint_count++] =
       endpoint_p;
+  endpoint_p->is_single_threaded = single_threaded;
+  LCIU_spinlock_init(&endpoint_p->lock);
   // Create end-point;
   FI_SAFECALL(fi_endpoint(endpoint_p->server->domain, endpoint_p->server->info,
                           &endpoint_p->ep, NULL));
@@ -207,4 +209,5 @@ void LCISD_endpoint_fina(LCIS_endpoint_t endpoint_pp)
   FI_SAFECALL(fi_close((struct fid*)&endpoint_p->ep->fid));
   FI_SAFECALL(fi_close((struct fid*)&endpoint_p->cq->fid));
   FI_SAFECALL(fi_close((struct fid*)&endpoint_p->av->fid));
+  LCIU_spinlock_fina(&endpoint_p->lock);
 }
\ No newline at end of file
diff --git a/src/backend/ofi/server_ofi.h b/src/backend/ofi/server_ofi.h
index b6442f8..3896fa8 100644
--- a/src/backend/ofi/server_ofi.h
+++ b/src/backend/ofi/server_ofi.h
@@ -41,6 +41,8 @@ typedef struct __attribute__((aligned(LCI_CACHE_LINE))) LCISI_endpoint_t {
   struct fid_cq* cq;
   struct fid_av* av;
   fi_addr_t* peer_addrs;
+  bool is_single_threaded;
+  LCIU_spinlock_t lock;
 } LCISI_endpoint_t;
 
 extern int g_next_rdma_key;
@@ -171,9 +173,18 @@ static inline LCI_error_t LCISD_post_sends(LCIS_endpoint_t endpoint_pp,
                                            LCIS_meta_t meta)
 {
   LCISI_endpoint_t* endpoint_p = (LCISI_endpoint_t*)endpoint_pp;
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded &&
+      !LCIU_try_acquire_spinlock(&endpoint_p->lock))
+    return LCI_ERR_RETRY_LOCK;
+#endif
   ssize_t ret =
       fi_injectdata(endpoint_p->ep, buf, size, (uint64_t)LCI_RANK << 32 | meta,
                     endpoint_p->peer_addrs[rank]);
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded)
+    LCIU_release_spinlock(&endpoint_p->lock);
+#endif
   if (ret == FI_SUCCESS)
     return LCI_OK;
   else if (ret == -FI_EAGAIN)
@@ -189,10 +200,19 @@ static inline LCI_error_t LCISD_post_send(LCIS_endpoint_t endpoint_pp, int rank,
                                           LCIS_meta_t meta, void* ctx)
 {
   LCISI_endpoint_t* endpoint_p = (LCISI_endpoint_t*)endpoint_pp;
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded &&
+      !LCIU_try_acquire_spinlock(&endpoint_p->lock))
+    return LCI_ERR_RETRY_LOCK;
+#endif
   ssize_t ret =
       fi_senddata(endpoint_p->ep, buf, size, ofi_rma_lkey(mr),
                   (uint64_t)LCI_RANK << 32 | meta, endpoint_p->peer_addrs[rank],
                   (struct fi_context*)ctx);
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded)
+    LCIU_release_spinlock(&endpoint_p->lock);
+#endif
   if (ret == FI_SUCCESS)
     return LCI_OK;
   else if (ret == -FI_EAGAIN)
@@ -216,8 +236,17 @@ static inline LCI_error_t LCISD_post_puts(LCIS_endpoint_t endpoint_pp, int rank,
   } else {
     addr = offset;
   }
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded &&
+      !LCIU_try_acquire_spinlock(&endpoint_p->lock))
+    return LCI_ERR_RETRY_LOCK;
+#endif
   ssize_t ret = fi_inject_write(endpoint_p->ep, buf, size,
                                 endpoint_p->peer_addrs[rank], addr, rkey);
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded)
+    LCIU_release_spinlock(&endpoint_p->lock);
+#endif
   if (ret == FI_SUCCESS)
     return LCI_OK;
   else if (ret == -FI_EAGAIN)
@@ -241,8 +270,17 @@ static inline LCI_error_t LCISD_post_put(LCIS_endpoint_t endpoint_pp, int rank,
   } else {
     addr = offset;
   }
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded &&
+      !LCIU_try_acquire_spinlock(&endpoint_p->lock))
+    return LCI_ERR_RETRY_LOCK;
+#endif
   ssize_t ret = fi_write(endpoint_p->ep, buf, size, ofi_rma_lkey(mr),
                          endpoint_p->peer_addrs[rank], addr, rkey, ctx);
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded)
+    LCIU_release_spinlock(&endpoint_p->lock);
+#endif
   if (ret == FI_SUCCESS)
     return LCI_OK;
   else if (ret == -FI_EAGAIN)
@@ -267,8 +305,17 @@ static inline LCI_error_t LCISD_post_putImms(LCIS_endpoint_t endpoint_pp,
   } else {
     addr = offset;
   }
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded &&
+      !LCIU_try_acquire_spinlock(&endpoint_p->lock))
+    return LCI_ERR_RETRY_LOCK;
+#endif
   ssize_t ret = fi_inject_writedata(endpoint_p->ep, buf, size, meta,
                                     endpoint_p->peer_addrs[rank], addr, rkey);
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded)
+    LCIU_release_spinlock(&endpoint_p->lock);
+#endif
   if (ret == FI_SUCCESS)
     return LCI_OK;
   else if (ret == -FI_EAGAIN)
@@ -294,8 +341,17 @@ static inline LCI_error_t LCISD_post_putImm(LCIS_endpoint_t endpoint_pp,
   } else {
     addr = offset;
   }
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded &&
+      !LCIU_try_acquire_spinlock(&endpoint_p->lock))
+    return LCI_ERR_RETRY_LOCK;
+#endif
   ssize_t ret = fi_writedata(endpoint_p->ep, buf, size, ofi_rma_lkey(mr), meta,
                              endpoint_p->peer_addrs[rank], addr, rkey, ctx);
+#ifdef LCI_IBV_ENABLE_TRY_LOCK_QP
+  if (!endpoint_p->is_single_threaded)
+    LCIU_release_spinlock(&endpoint_p->lock);
+#endif
   if (ret == FI_SUCCESS)
     return LCI_OK;
   else if (ret == -FI_EAGAIN)
