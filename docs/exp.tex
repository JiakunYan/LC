\pgfplotstableread{data/tableinsert.dat}\mytableinsert
\pgfplotstableread{data/tablefind.dat}\mytablefind

\begin{figure*}[ht]
  \centering
  \begin{adjustbox}{width=.8\textwidth}
    \subfigure[Latency per successful \texttt{insert}.]{
      \centering
      \begin{tikzpicture}[scale=.8]
        \begin{axis}[xlabel=N Threads, ylabel=Latency (usec), ymin=0, scaled ticks=false, tick label style={/pgf/number format/fixed},
            boxplot/draw direction=y,
            ytick distance={0.1},
            ymax={0.6},
            cycle list={{red},{blue},{black}},
            legend pos={north west}
          ]
          % hack to make legend
          \addlegendimage{area legend,fill=red,draw=black}; \addlegendentry{arr};
          \addlegendimage{area legend,fill=blue,draw=black}; \addlegendentry{ch};
          \addlegendimage{area legend,fill=black,draw=black}; \addlegendentry{tbb};

          \pgfplotsinvokeforeach{3,...,23}{
            \addplot+[boxplot prepared from table={table=\mytableinsert,
              row=#1, lower whisker=lw, upper whisker=uw, lower quartile=lq, upper quartile=uq,
            median=med, draw position=nthreads}, boxplot prepared] coordinates {};
          }
        \end{axis}
      \end{tikzpicture}
    }

    \subfigure[Latency per fail \texttt{insert} followed by an \texttt{erase}.]{
      \centering
      \begin{tikzpicture}[scale=.8]
        \begin{axis}[xlabel=N Threads, ylabel=Latency (usec), ymin=0, scaled ticks=false, tick label style={/pgf/number format/fixed},
            boxplot/draw direction=y,
            ytick distance={0.1},
            ymax={0.6},
            cycle list={{red},{blue},{black}},
            legend pos={north west}
          ]
          % hack to make legend
          \addlegendimage{area legend,fill=red,draw=black}; \addlegendentry{arr};
          \addlegendimage{area legend,fill=blue,draw=black}; \addlegendentry{ch};
          \addlegendimage{area legend,fill=black,draw=black}; \addlegendentry{tbb};

          \pgfplotsinvokeforeach{3,...,23}{
            \addplot+[boxplot prepared from table={table=\mytablefind,
              row=#1, lower whisker=lw, upper whisker=uw, lower quartile=lq, upper quartile=uq,
            median=med, draw position=nthreads}, boxplot prepared] coordinates {};
          }
        \end{axis}
      \end{tikzpicture}
    }
  \end{adjustbox}

  \caption{Latency of our hash-table implementation (\textit{arr}) in comparison
  to libcuckoo (\textit{ch}) and tbb concurrent hash map (\textit{tbb}).  Each
  hash-table is created with the initial size of $2^{16}$, the number of
  insertion per thread is chosen so that there is enough room and no expansion is
  required. TBB is also compiled with \textit{tbb-malloc} to improve performance.
  Latency exceeds an 0.5 microsecond is not shown.\label{fig:hash-table}}

\end{figure*}

\subsection{Component overheads}
In this section we evaluate our implementation of each individual component.
Understanding them individually gives us an idea on the minimum cost of the overall
system.

\subsubsection{Concurrent Hash-Table}
To evaluate the overhead due to hash-table operations, we measure the latency 
on hash-table operations in the two following scenarios when performing them
in a number of POSIX threads:

\begin{itemize}
  \item A thread performs \texttt{insert} when there is no item with the same key.
  \item A thread performs \texttt{insert} and there is already items in the hash-table, and it subsequently
    performs \texttt{erase}.
\end{itemize}

 The two scenarious represent the only two possible runtime execution of the
 hash-table in our algorithms, thus measuring the latency in both cases give us
 an idea on how it will add to the overhead of MPI procedure. To justify the
 benefit of customization, we also compare ourselves to two popular general
 purposes hash-tables: libcuckoo implementing cuckoo hashing (\textit{ch})
 \cite{chasing}, and TBB concurrent hashmap (\textit{tbb}) \cite{tbb}.

Figure~\ref{fig:hash-table} shows the result of our experiment. In both cases,
both TBB concurrent hash map and libcuckoo shows inconsistent latency when
there is more concurrent threads, which is the result of conflicts. Since our
hash-table is optimized for these patterns, our latency is almost always as low
as 50 nanosecond. This latency is consitent with our expectation that our cost
for the hash-table is equivalent to 2 memory writes.

\subsubsection{Concurrent Packet Pool}
The overhead due to packet pool is measured as the sum of the latency of
\texttt{get} and \texttt{ret} operation. We evaluate this quantity by performs
a random number of \texttt{get} followed by the same number of \texttt{ret} in
each thread. The range of the random number is chosen so that the sum of all
threads does not exceed the total number of available packets: the maximum is
number of packets divided by number of threads.

\subsubsection{Thread scheduler}
The overhead due to thread scheduler is measured as scheduling time which consists
of two components:
\begin{itemize}
    \item Mark a thread as schedulable: the latency of a \texttt{ThreadSignal}.
    \item Finding schedulable threads: the latency taken when the scheduler is free
      until it finds a thread to execute i.e. time taken when thread is yielded until
      it is picked up again.
\end{itemize}

\subsection{Microbenchmarks and Application Evaluation}
App/benchmarks: pingpong, pingpong_mt, stencil, ?bfs, ?uts.
This is the plan:
  \begin{verbatim}
  We compare multi-threaded apps/benchmarks with:
    - MVAPICH2: original MPI.
    - MPI-PTHREAD-POOL: hash-table
    - MPI-PTHREAD: hash-table + pool
    - MPI-FULL: hash-table + pool + thread
  \end{verbatim}
